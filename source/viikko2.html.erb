---
  title: Viikko 2
  exercise_page: false
  quiz_page: false
  published: true
---


<% partial 'partials/hint', locals: { name: 'Viikon 2 etapit' } do %>


  <ul>
    <li>
      Githubissa olevan projektin rakenne on selkeä
      <ul>
	<li>erillinen kansio sovellukselle</li>
	<li>erillinen kansio dokumentaatiolle</li>
	<li>sovelluksen toiminnallisuutta jaoteltu kansioihin</li>
      </ul>
    </li>
    <li>
      Projektissa käytössä tietokanta sekä yksi tietokohde (tietokantataulu).
      <ul>
	<li>tietokannasta voi hakea tietoa</li>
	<li>tietokantaan voi lisätä tietoa</li>
	<li>tietokannassa olevaa tietoa voi päivittää</li>
	<li>tietokantaa käytetään paikallisesti SQLite-tietokannanhallintajärjestelmän avulla</li>
      </ul>
    </li>
    <li>
      Projektissa on näkymät (html-sivut) tiedon listaamiseen, tiedon lisäämiseen sekä tiedon päivittämiseen (mikäli käyttötapausten kannalta oleellista). HTML-sivujen tarjoama toiminnallisuus yhteydessä Flaskin kautta tietokantaan.
    </li>
    <li>
      Dokumentaatio kehittyy. 
      <ul>
	<li>
	  Projektin päädokumentti (juuren README.md) sisältää aihekuvauksen.
	</li>
	<li>	  
	  Dokumentaatiokansiossa sovelluksen toiminnallisuuden kannalta oleelliset käyttötapaukset tai user storyt (kts. <a href="https://www.mountaingoatsoftware.com/agile/user-stories" target="_blank" norel>esimerkkejä</a>).
	</li>
	<li>
	  Dokumentaatiokansiossa hahmotelma tietokantakaaviosta.
	</li>
	<li>
	  Projektin päädokumentti (juuren README.md) sisältää linkit käyttötapauksiin tai user storyihin sekä tietokantakaaviohahmotelmaan.
	</li>
      </ul>
    </li>
    
    <li>
      Commit-viestit githubiin järkeviä.
    </li>
    <li>
      Githubissa ei turhia tiedostoja (virtuaaliympäristöä kuvaava kansio, cachet, käyttöjärjestelmäkohtaiset tiedot..).
    </li>
  </ul>
  
  
<% end %>


<p>
  Tietokantasovellus-kurssin toisen viikon materiaali sisältää esimerkin tehtävien hallintaan tarkoitetun sovelluksen luomisesta. Materiaalissa luodaan ensin hieman isommalle projektille sopiva projektirakenne, jonka jälkeen luodaan tehtävien hallintaan tarvittavaa toiminnallisuutta projektia varten. Esimerkin keskiössä on tietokannan käyttö valmiin ORM-kirjaston kautta sekä tietokannan ja näkymien yhteiskäyttö.
</p>

<% partial 'partials/material_heading' do %>
  Hieman isomman projektin rakenne
<% end %>

<p>
  <em>
    Huom! Tässä pohjan rakennus lähtee tyhjästä. Kun seuraat esimerkkiä, mieti miten saat saman tehtyä jo olemassaolevalle projektipohjallesi -- sen sijaan, että teet uusia tiedostoja, siirtelet todennäköisesti asioita paikasta toiseen.
  </em>
</p>

<p>
  Luodaan ensin "walking skeleton" eli toimiva lähes tyhjä projektipohja. Kun käytössämme on toimiva pohja, voimme aloittaa toiminnallisuuden lisäämisen. Tämä osa kertaa vahvasti viikon 1 materiaalia, mutta mukana on uutta tietoa esimerkiksi moduulien (kansioiden) hallintaan.
</p>

<p>
  Koska projektimme on laajempi, suunnitellaan projektin hakemistorakenne uusiksi. Oleellisin muutos edelliseen on se, että sovellukseen liittyvät lähdekooditiedostot ovat omassa kansiossaan -- tällöin projektin kasvaessa juurihakemisto pysyy selkeänä.
</p>

<ul>
  <li><code>/venv/</code> - kansio sisältää virtuaaliympäristön tiedot.</li>
  <li><code>/application/</code> - kansio sisältää sovelluksen tiedostot.</li>
  <li><code>/documentation/</code> - kansio sisältää sovelluksen dokumentaation.</li>
  <li><code>README.md</code> - juurikansiossa oleva dokumentaatio, näkyy projektiin liittyvän Github-repon etusivulla.</li>
  <li><code>run.py</code> - sovelluksen käynnistämiseen tarvittava Python-lähdekoodi.</li>
  <li><code>requirements.txt</code> - virtuaaliympäristön riippuvuudet.</li>
  <li><code>Procfile</code> - ohjeistus tiedoston käynnistämiseen Herokussa.</li>
  <li><code>.gitignore</code> - tieto projektiin liittyvistä tiedostoista, joita ei säilötä versionhallinnassa.</li>
</ul>

<% partial 'partials/material_sub_heading' do %>
  Sovelluskansion luominen ja virtuaaliympäristö
<% end %>

<p>
  Luodaan ensin kansio sovellukselle, jonka alle kaikki tiedot tulevat. Tässä esimerkissä rakennetaan tehtävien hallintaan käytettävää sovellusta, joten luonteva nimi kansiolle on <code>todosovellus</code>.
</p>

<% partial 'partials/terminal' do %>
  $ mkdir todosovellus
  $ cd todosovellus
  ~/todosovellus$
<% end %>

<p>
  Luodaan seuraavaksi kansioon virtuaaliympäristö <code>venv</code>, johon tulee projektin riippuvuudet.
</p>

<% partial 'partials/terminal' do %>
  ~/todosovellus$ python3 -m venv venv
  ~/todosovellus$ ls -a
  . .. venv
  ~/todosovellus$ 
<% end %>

<p>
  Aktivoidaan tämän jälkeen virtuaaliympäristö.
</p>

<% partial 'partials/terminal' do %>
  ~/todosovellus$ source venv/bin/activate
  (venv) ~/todosovellus$ 
<% end %>

<p>
  Nyt ladattavat riippuvuudet tulevat tämän projektin käyttöön, eivätkä ne vaikuta muihin projekteihin.
</p>

<p>
  Lisätään jo tässä vaiheessa "venv"-kansio tiedostoon <code>.gitignore</code>. Tällöin virtuaaliympäristöön liittyviä tiedostoja ei lisätä versionhallintaan.
</p>

<% partial 'partials/terminal' do %>
  (venv) ~/todosovellus$ echo "venv" >> .gitignore
  (venv) ~/todosovellus$ cat .gitignore
  venv
  (venv) ~/todosovellus$ ls -a
  . .. venv .gitignore
  (venv) ~/todosovellus$
<% end %>


<% partial 'partials/material_sub_heading' do %>
  Riippuvuuksien hakeminen
<% end %>

<p>
  Haetaan seuraavaksi projektin käyttöön Flask. Päivitetään ensin riippuvuuksien hakemiseen tarvittava <code>pip</code>.
</p>

<% partial 'partials/terminal' do %>
  ~/todosovellus$ source venv/bin/activate
  (venv) ~/todosovellus$ pip install --upgrade pip
    ...
  Successfully installed pip-9.0.1
  (venv) ~/todosovellus$ 
<% end %>

<p>
  Ja asennetaan Flask.
</p>

<% partial 'partials/terminal' do %>
  (venv) ~/todosovellus$ pip install Flask
    ... 
  Successfully installed Flask-0.12.2 Jinja2-2.10 MarkupSafe-1.0 Werkzeug-0.14.1 click-6.7 itsdangerous-0.24
  (venv) ~/todosovellus$
<% end %>


<% partial 'partials/material_sub_heading' do %>
  Sovellus omaan kansioon
<% end %>

<p>
  Aloitetaan nyt sovelluskansion luominen. Sovellus tulee kansioon <code>/application</code> -- luodaan se.
</p>

<% partial 'partials/terminal' do %>
  (venv) ~/todosovellus$ mkdir application
  (venv) ~/todosovellus$ ls -a
  . .. application venv .gitignore
  (venv) ~/todosovellus$ 
<% end %>

<p>
  Python käsittelee jokaisen kansion moduulina, jotka käyttäytyvät hieman kuin Javan pakkaukset. Jokaisella moduulilla (pakkauksella) tulee olla tiedosto nimeltä <code>__init__.py</code>, joka kertoo Pythonille, että kyseinen kansio sisältää projektin kannalta oleellista lähdekoodia.
</p>

<p>
  Tiedosto <code>__init__.py</code> voi sisältää myös lähdekoodia, joka suoritetaan sovelluksen alustamisen yhteydessä. Sovelluksemme on Flask-sovellus -- käynnistetään Flask osana <code>__init__.py</code>-tiedoston suoritusta. Knasiossa <code>application</code> olevan tiedoston <code>__init__.py</code> sisältö tulee olemaan aluksi seuraava.
</p>

<% partial 'partials/python_highlight' do %>
  from flask import Flask
  app = Flask(__name__)
<% end %>

<% partial 'partials/terminal' do %>
  (venv) ~/todosovellus$ cd application
  (venv) ~/todosovellus/application$ cat __init__.py
  from flask import Flask
  app = Flask(__name__)
  (venv) ~/todosovellus/application$ cd ..
  (venv) ~/todosovellus$ 
<% end %>

<p>
  Sovelluksen käyttöön tulee siis muuttuja <code>app</code>, joka viittaa Flaskiin.
</p>

<p>
  Luodaan seuraavaksi sovelluksen juurikansioon tiedosto <code>run.py</code>, jota käytetään sovelluksen käynnistämiseen. Tiedoston ensimmäiselle riville tulee komento <code>from application import app</code>, eli lataa moduulista <code>application</code> muuttuja <code>app</code>. Tässä moduuli <code>application</code> tarkoittaa käytännössä kansiota <code>application</code> ja <code>app</code> kansiossa olevan <code>__init__.py</code> lähdekoodin suorittamisen yhteydessä luotavaa <code>app</code>-muuttujaa, joka viittaa Flaskiin.
</p>

<p>
  Tämän lisäksi tiedostoon tulee sovelluksen käynnistämiseen tarvittava komento. Tiedosto <code>run.py</code> kokonaisuudessaan.
</p>

<% partial 'partials/python_highlight' do %>
from application import app

if __name__ == '__main__':
    app.run(debug=True)
<% end %>

<p>
  Komentoriviltä tiedoston <code>run.py</code> tarkastelu onnistuu <code>cat</code>-komennolla.
</p>

<% partial 'partials/terminal' do %>
  (venv) ~/todosovellus$ cat run.py
  from application import app

  if __name__ == '__main__':
      app.run(debug=True)
  (venv) ~/todosovellus$ ls -a
  . .. application venv run.py .gitignore
  (venv) ~/todosovellus$ 
<% end %>

<p>
  Nyt sovelluksen voi käynnistää komennolla <code>python run.py</code>.
</p>

<% partial 'partials/terminal' do %>
  (venv) ~/todosovellus$ python run.py
  * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)
  * Restarting with stat
  * Debugger is active!
  * Debugger PIN: 140-705-06
<% end %>

<p>
  Kun osoite <a href="http://localhost:5000/" target="_blank" norel>http://localhost:5000/</code> tai <a href="http://127.0.0.1:5000/" target="_blank" norel>http://127.0.0.1:5000/</a> avataan selaimessa, vastauksena on sivu, joka kertoo ettei osoitteesta löydy mitään.
</p>

<img src="/img/not-found.png" alt="Not found."/>

<p>
  Tarkemmin ottaen sivu kertoo, että osoitteessa <em>on</em> olemassa pyyntöjä vastaanottava palvelin. Palvelimella ei vaan ole kytketty toiminnallisuutta kyseiseen polkuun.
</p>

<p>
  Sovellus sammuu painamalla <code>ctrl</code> ja <code>c</code> samaan aikaan terminaalissa. Huomaamme vielä, että kansioon <code>application</code> on tullut sovelluksen käynnistyksen yhteydessä uutta sisältöä.
</p>

<% partial 'partials/terminal' do %>
  (venv) ~/todosovellus$ python run.py
  * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)
  * Restarting with stat
  * Debugger is active!
  * Debugger PIN: 140-705-06
  ^C(venv) ~/todosovellus$ ls -a application
  . .. __pycache__ __init__.py
  (venv) ~/todosovellus$ 
<% end %>

<p>
  Jokaiseen kansioon, jossa olevassa python-tiedostossa tuodaan käyttöön muiden moduulien tietoja (esim <code>from flask import Flask</code>), luodaan Pythonin puolesta <code>__pycache__</code>-kansio. Se sisältää paikallisia välimuistitiedostoja sovellukseen liittyen. Emme halua niitä versionhallintaan, joten päivitetään projektin <code>.gitignore</code>-tiedoston sisältöä.
</p>

<% partial 'partials/terminal' do %>
  (venv) ~/todosovellus$ cat .gitignore
  venv
  (venv) ~/todosovellus$ echo "__pycache__" >> .gitignore
  (venv) ~/todosovellus$ cat .gitignore
  venv
  __pycache__
  (venv) ~/todosovellus$ 
<% end %>


<% partial 'partials/material_sub_heading' do %>
  Ensimmäiset HTML-sivut
<% end %>

<p>
  Tehdään sovellukselle HTML-sivut, joita käytetään sisällön näyttämiseen. Luodaan kansioon <code>application</code> kansio <code>templates</code>, jonka alle HTML-sivut asetetaan asetetaan.
</p>


<% partial 'partials/terminal' do %>
  (venv) ~/todosovellus$ cd application
  (venv) ~/todosovellus/application$ mkdir templates
  (venv) ~/todosovellus/application$ cd templates
  (venv) ~/todosovellus/application/templates$ 
<% end %>

<p>
  Luodaan kansioon tiedostot <code>layout.html</code>, jota käytetään sivun ulkoasun pohjana, ja <code>index.html</code>, joka toimii sivuston pääsivuna.
</p>

<p>
  Tiedoston <code>layout.html</code> sisällöksi tulee seuraava.
</p>

<% partial 'partials/xml_highlight' do %>
  &lt;!DOCTYPE html&gt;
  &lt;html&gt;
    &lt;head&gt;
      &lt;meta charset="utf-8"&gt;
      &lt;title&gt;TodoApp&lt;/title&gt;
    &lt;/head&gt;

    &lt;body&gt;
      {% block body %}
        &lt;p&gt;
          Content.
        &lt;/p&gt;
      {% endblock %}
    &lt;/body&gt;
  &lt;/html&gt;
<% end %>


<p>
  Ja tiedoston <code>index.html</code> sisällöksi seuraava.
</p>

<% partial 'partials/xml_highlight' do %>
  {% extends "layout.html" %}

  {% block body %}
    &lt;p&gt;
      Hello world!
    &lt;/p&gt;
  {% endblock %}
<% end %>

<p>
  Nyt kansion <code>templates</code> sisältö on seuraava.
</p>

<% partial 'partials/terminal' do %>
  (venv) ~/todosovellus/application/templates$ ls -a
  . .. index.html layout.html
<% end %>



<% partial 'partials/material_sub_heading' do %>
  Sivujen näyttäminen sovelluksen kautta
<% end %>

<p>
  Lisätään sovellukselle seuraavaksi toiminnallisuus, joka näyttää käyttäjälle edellä luodun HTML-sivun sisällön. Luodaan kansioon <code>application</code> tiedosto <code>views.py</code>, joka sisältää ohjeistuksen sovelluksen pääsivulle pääsemiseen. 
</p>

<p>
  Tiedosto <code>views.py</code> ohjeistaa Flaskia käsittelemään jokaisen sovelluksen juuripolkuun <code>/</code> tulevan pyynnön siten, että käyttäjälle näytetään tiedoston <code>index.html</code> sisältö. 
</p>

<% partial 'partials/python_highlight' do %>
  from flask import render_template
  from application import app

  @app.route("/")
  def index():
      return render_template("index.html")
<% end %>

<p>
  Kun käynnistämme sovelluksen ja avaamme osoitteen <a href="http://localhost:5000" target="_blank" norel>http://localhost:5000</a> sivu näyttää yhä seuraavalta.
</p>

<img src="/img/not-found.png" alt="Not found." />

<p>
  &nbsp;
</p>

<p>
  Sivua ei vieläkään löydy.
</p>

<p>
  Tämä johtuu siitä, että sovellustamme ei ole ohjeistettu lataamaan tiedoston <code>views.py</code> sisältöä käyttöön. Muokataan kansiossa <code>application</code> olevaa <code>__init__.py</code> tiedostoa siten, että tiedoston <code>views.py</code> sisältö ladataan käyttöön sovelluksen käynnistyessä.
</p>

<p>
  Tarkemmin sanoen, lisätään tiedostoon rivi <code>from application import views</code>. Tiedosto <code>__init__.py</code> on nyt kokonaisuudessaan seuraava.
</p>

<% partial 'partials/python_highlight' do %>
  from flask import Flask
  app = Flask(__name__)

  from application import views
<% end %>

<p>
  Nyt sovellus toimii ja näyttää halutun sivun.
</p>


<img src="/img/hello-world.png" alt="Hello world!" />



<% partial 'partials/material_sub_heading' do %>
  Valmius Herokuun siirtämiseen
<% end %>

<p>
  Heroku käyttää palvelimen käynnistämisessä <a href="http://gunicorn.org/" target="_blank" norel>Gunicorn</a>-palvelinta. Lisätään se sovelluksen käyttöön.
</p>


<% partial 'partials/terminal' do %>
  (venv) ~/todosovellus$ pip install gunicorn
  Collecting gunicorn
    ... 
  Successfully installed gunicorn-19.7.1
  (venv) ~/todosovellus$ 
<% end %>

<p>
  Luodaan seuraavaksi sovellukselle tiedosto <code>Procfile</code>, joka antaa Herokulle ohjeet sovelluksen käynnistämiseen. Haluamme, että Heroku käynnistää <code>application</code>-moduulissa määritellyn app-sovelluksen, eli Flaskin.
</p>

<% partial 'partials/terminal' do %>
  (venv) ~/todosovellus$ echo "web: gunicorn application:app" > Procfile
  (venv) ~/todosovellus$ cat Procfile
  web: gunicorn application:app
  (venv) ~/todosovellus$ 
<% end %>

<p>
  Heroku -- ja oikeastaan muutkin sovellusta käyttävät tahot -- tarvitsevat myös tiedon sovelluksen käyttämistä riippuvuuksista. Lisätään riippuvuudet <code>requirements.txt</code>-tiedostoon.
</p>

<% partial 'partials/terminal' do %>
  (venv) ~/todosovellus$ pip freeze | grep -v pkg-resources > requirements.txt
  (venv) ~/todosovellus$ cat requirements.txt
  click==6.7
  Flask==0.12.2
  gunicorn==19.7.1
  itsdangerous==0.24
  Jinja2==2.10
  MarkupSafe==1.0
  Werkzeug==0.14.1
  (venv) ~/todosovellus$ 
<% end %>

<p>
  Yllä poistamme myös riippuvuuden <code>pkg-resources</code>, jonka olemassaolo aiheuttaisi ongelmia Herokussa.
</p>

<p>
  Nyt sovelluksen saisi tarvittaessa käynnistymään Herokussa.
</p>


<% partial 'partials/material_sub_heading' do %>
  Sovelluksen rakenne
<% end %>

<p>
  Tarkastellaan vielä sovelluksen rakennetta kokonaisuudessaan.
</p>

<% partial 'partials/terminal' do %>
  ── application
  │   ├── __init__.py
  │   ├── templates
  │   │   ├── index.html
  │   │   └── layout.html
  │   ├── views.py
  ├── run.py
  ├── .gitignore
  ├── Procfile
  ├── requirements.txt  
  ...
<% end %>

<p>
  Projektista puuttuu kansio <code>documentation</code> sekä tiedosto <code>README.md</code>.
</p>


<% partial 'partials/terminal' do %>
  (venv) ~/todosovellus$ mkdir documentation
  (venv) ~/todosovellus$ echo "# TodoApp" > README.md
<% end %>

<p>
  Sovelluksen runko on lähes valmis. Mutta...
</p>

<p>
  Sovelluksessa saattaa olla ohjelmointiympäristöön liittyviä tiedostoja, jotka kannattaa jättää pois versionhallinnasta. Osoitteessa <a href="https://github.com/github/gitignore/blob/master/Python.gitignore" target="_blank" norel>https://github.com/github/gitignore/blob/master/Python.gitignore</a> on hyvä lista <code>.gitignore</code>-tiedostoon lisättävistä asioista.
</p>

<p>
  Laajemmin ottaen voit ajatella versionhallinnassa säilöttävien asioiden lisäämisestä seuraavasti: "oletko luonut tiedoston tai kansion? Jos et, tiedosto/kansio on autogeneroitu ja kuuluu gitignoreen".
</p>

<p> 


<% partial 'partials/material_heading' do %>
  Tehtävien hallinta
<% end %>

<p>
  Luodaan tässä sovellus tehtävien hallintaan. Sovellus tarjoaa listauksen tehtävistä sekä mahdollisuuden tehtävien luomiseen, tarkasteluun, muokkaamiseen ja poistamiseen.
</p>

<p>
  Luodaan ensin sovellukseemme erillinen kansio <code>tasks</code> (kansio <code>tasks</code> tulee kansion <code>application</code> alikansioksi) ja luodaan sen sisälle tyhjä <code>__init__.py</code>-tiedosto. Kansioon <code>tasks</code> tulee tehtävien hallintaan liittyvä ohjelmakoodi.
</p>


<% partial 'partials/terminal' do %>
  ── application
  │   ├── __init__.py
  │   ├── tasks
  │   │   └── __init__.py
  │   ├── templates
  │   │   ├── index.html
  │   │   └── layout.html
  │   ├── views.py
  ├── run.py
  ├── .gitignore
  ├── Procfile
  ├── requirements.txt
  ├── README.md
  ...
<% end %>


<% partial 'partials/material_sub_heading' do %>
  Sovelluksen polut
<% end %>

<p>
  Uutta toiminnallisuutta rakennettaessa on hyvä miettiä sekä toiminnallisuus että toiminnallisuuteen liittyvät polut. Jokaiseen polkuun tulee liittyä selkeä tehtävä -- pyyntömetodin GET tulee liittyä aina tiedon hakemiseen, ja pyyntömetodin POST aina tiedon lähettämiseen.
</p>

<p>
  Sovitaan, että polut ja toiminnallisuudet ovat seuravat.
</p>

<ul>
  <li>GET <code>/tasks/</code> näyttää tehtävät listana.</li>
  <li>GET <code>/tasks/new/</code> näyttää lomakkeen, jota käytetään uuden tehtävän luomiseen.</li>
  <li>POST <code>/tasks/</code> lisää uuden tehtävän pyynnössä tulevien tietojen perusteella.</li>
  <li>POST <code>/tasks/42/</code> asettaa tehdyksi sen tehtävän, jonka pääavaimen arvo on <code>42</code>.</li>
</ul>


<% partial 'partials/material_sub_heading' do %>
  Tietokannan käyttöönotto
<% end %>

<p>
  Tuodaan sovelluksen käyttöön tietokanta. Tietokantatoiminnallisuuden toteuttamiseen käytetään <a href="https://www.sqlalchemy.org/" target="_blank" norel>SQLAlchemy</a>-kirjastoa. SQLAlchemy on ORM-kirjasto, joka tarjoaa tuen luokkien ja tietokannan taulujen kytkemiseen. Flaskia varten on kehitetty laajennus <code>flask-sqlalchemy</code> kyseisestä kirjastosta. Tuodaan se käyttöön.
</p>

<% partial 'partials/terminal' do %>
  (venv) ~/todosovellus$ pip install flask-sqlalchemy
  Collecting flask-sqlalchemy
  ...
  Successfully installed SQLAlchemy-1.2.5 flask-sqlalchemy-2.3.2
  (venv) ~/todosovellus$ 
<% end %>

<p>
  Hyödynnämme aluksi <a href="https://www.sqlite.org/index.html" target="_blank" norel>SQLite</a>-tietokannanhallintajärjestelmää, käsittelemme myöhemmin (noin viikko 3) PostgreSQL:n käyttöönottoa.
</p>

<p>
  Lisätään SQLAlchemyn käyttöönotto sovelluksemme <code>application</code>-kansiossa sijaitsevaan <code>__init__.py</code>-tiedostoon. Tiedosto sisältää sovelluksen käynnistyessä suoritettavan lähdekoodin. Lähdekoodi on kommentoitu.
</p>

<% partial 'partials/python_highlight' do %>
  # Tuodaan Flask käyttöön
  from flask import Flask
  app = Flask(__name__)

  # Tuodaan SQLAlchemy käyttöön
  from flask_sqlalchemy import SQLAlchemy
  # Käytetään tasks.db-nimistä SQLite-tietokantaa. Kolme vinoviivaa
  # kertoo, tiedosto sijaitsee tämän sovelluksen tiedostojen kanssa
  # samassa paikassa
  app.config["SQLALCHEMY_DATABASE_URI"] = "sqlite:///tasks.db"
  # Pyydetään SQLAlchemyä tulostamaan kaikki SQL-kyselyt
  app.config["SQLALCHEMY_ECHO"] = True

  # Luodaan db-olio, jota käytetään tietokannan käsittelyyn
  db = SQLAlchemy(app)

  # Luetaan kansiosta application tiedoston views sisältö
  from application import views


  # Luodaan lopulta tarvittavat tietokantataulut
  db.create_all()
<% end %>

<p>
  Sovelluksessa on nyt siis käytössä <code>db</code>-olio, jota käytetään tietokantaan liittyvien operaatioiden hallinnassa.
</p>

<p>
  SQLAlchemyä käytettäessä tietokantataulujen määrittely tapahtuu ohjelmallisesti. Haluamme, että jokaiseen tehtävään liittyy tieto sen nimestä sekä siitä, että onko tehtävä tehty. Tämän lisäksi jokaisella tehtävällä tulee olla luonnollisesti pääavain sekä tieto tehtävän luomis- ja mahdollisesta päivityspäivästä.
</p>

<p>
  Luodaan kansioon <code>tasks</code> tiedosto <code>models.py</code>. Tiedostoon <code>models.py</code> tulee tehtävien hallintaan liittyvä luokka. Tiedoston sisältö on seuraava.
</p>

<% partial 'partials/python_highlight' do %>
  from application import db

  class Task(db.Model):
      id = db.Column(db.Integer, primary_key=True)
      date_created = db.Column(db.DateTime, default=db.func.current_timestamp())
      date_modified = db.Column(db.DateTime, default=db.func.current_timestamp(),
      onupdate=db.func.current_timestamp())

      name = db.Column(db.String(144), nullable=False)
      done = db.Column(db.Boolean, nullable=False)

      def __init__(self, name):
          self.name = name
          self.done = False
<% end %>

<p>
  Yllä etuliitteellä <code>db</code> määritellyt muuttujat ovat <code>flask-sqlalchemy</code>-kirjastosta saatavia apuvälineitä. Käytännössä yllä oleva luokka, yhdessä SQLAlchemyn kanssa, tuo käyttöömme tietokantataulun tehtävien määrittelyyn sekä siihen liittyvät yksinkertaiset kyselyt.
</p>

<p>
  Jotta luokka olisi käytössä, tulee se vielä tuoda <code>application</code>-kansion <code>__init__.py</code>-tiedostoon. Tiedoston <code>__init__.py</code> sisältö on nyt seuraava.
</p>

<% partial 'partials/python_highlight' do %>
  from flask import Flask
  app = Flask(__name__)

  from flask_sqlalchemy import SQLAlchemy
  app.config["SQLALCHEMY_DATABASE_URI"] = "sqlite:///tasks.db"
  app.config["SQLALCHEMY_ECHO"] = True

  db = SQLAlchemy(app)

  from application import views

  from application.tasks import models

  db.create_all()
<% end %>

<p>
  Sovelluksen käynnistäminen näyttää nyt hyvin mielenkiintoiselta. 
</p>

<% partial 'partials/terminal' do %>
  (venv) ~/todosovellus$ python run.py
  ... 
  2018-02-29 22:08:14,272 INFO sqlalchemy.engine.base.Engine 
  CREATE TABLE task (
      id INTEGER NOT NULL, 
      date_created DATETIME, 
      date_modified DATETIME, 
      name VARCHAR(144) NOT NULL, 
      done BOOLEAN NOT NULL, 
      PRIMARY KEY (id), 
      CHECK (done IN (0, 1))
  )
  ...
  * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)
  * Restarting with stat
  ...
  * Debugger is active!
  * Debugger PIN: 140-705-069
<% end %>

<p>
  Käynnistykseen liittyvä tulostus on tuttua, mutta mukana on myös paljon uutta. Yllä näemme CREATE TABLE -lauseen, joka suoritetaan sovelluksen käynnistyksen yhteydessä.
</p>

<p>
  Sovellukseemme ilmestyy nyt myös uusi tiedosto. Kansioon <code>application</code> tulee SQLiten hallinnoima tiedosto <code>tasks.db</code>.
</p>

<% partial 'partials/terminal' do %>
  ── application
  │   ├── __init__.py
  │   ├── tasks
  │   │   ├── models.py
  │   │   └── __init__.py
  │   ├── templates
  │   │   ├── index.html
  │   │   └── layout.html
  │   ├── views.py
  │   ├── tasks.db
  ├── run.py
  ├── .gitignore
  ├── Procfile
  ├── requirements.txt
  ├── README.md
  ...
<% end %>

<p>
  Tiedosto on normaali SQLiten avulla avattava tietokantatiedosto. Voimme tarkastella sitä myös sqlite3:n avulla.
</p>

<% partial 'partials/terminal' do %>
  (venv) ~/todosovellus$ sqlite3 application/tasks.db
  SQLite version 3.11.0 2016-02-15 17:29:24
  Enter ".help" for usage hints.
  sqlite&gt; .schema
  CREATE TABLE task (
      id INTEGER NOT NULL, 
      date_created DATETIME, 
      date_modified DATETIME, 
      name VARCHAR(144) NOT NULL, 
      done BOOLEAN NOT NULL, 
      PRIMARY KEY (id), 
      CHECK (done IN (0, 1))
  );
  sqlite&gt; SELECT * FROM Task;
  sqlite&gt; .exit
  (venv) ~/todosovellus$
<% end %>

<p>
  Näyttää suhteellisen tutulta tietokantojen perusteet -kurssia ajatellen. Yritetään seuraavaksi luoda toiminnallisuus tiedon tietokantaan lisäämiseen.
</p>


<% partial 'partials/material_sub_heading' do %>
  Tiedon lisääminen tietokantaan
<% end %>

<p>
  Tiedon lisäämiseksi tietokantaan tarvitsemme (1) palvelimelle toiminnallisuuden, joka lisää tietoa tietokantaan sekä (2) lomakkeen, joka lähetetään palvelimelle. Jatketaan samalla nimeämislinjalla, missä tehtävien hallintaan liittyvä toiminnallisuus lisätään kansioon <code>tasks</code>.
</p>

<p>
  Luodaan <code>application</code>-kansion alla olevaan kansioon <code>tasks</code> tiedosto nimeltä <code>views.py</code>. Tiedosto tulee sisältämään tehtävien käsittelyyn ja näkymien näyttämiseen liittyvät toiminnallisuudet.
</p>

<p>
  Lisätään tiedostoon ensin kaksi funktiota. Osoitteeseen <code>/tasks/new</code> tehty pyyntö näyttää käyttäjälle lomakkeen, jota käytetään tehtävien luomiseen, ja osoitteeseen <code>/tasks</code> tehty POST-pyyntö lisää uuden tehtävän pyynnössä lähetetyn lomakkeen perusteella. Oletetaan myös, että lomakkeessa on kenttä nimeltä <code>name</code>, johon asetetaan tehtävän nimi.
</p>

<p>
  Pyynnön käsittelyyn tarvittavat toiminnallisuudet löytyy flaskin <code>request</code>-moduulista. Lomakkeella lähetetyn kentän nimeltä "name" arvon saa kutsulla <code>request.form.get("name")</code>.
</p>

<% partial 'partials/python_highlight' do %>
  from application import app
  from flask import render_template, request

  @app.route("/tasks/new/")
  def tasks_form():
      return render_template("tasks/new.html")

  @app.route("/tasks/", methods=["POST"])
  def tasks_create():
      print(request.form.get("name"))
  
      return "hello world!"
<% end %>

<p>
  Kun käyttäjä avaa sovelluksen ja menee osoitteeseen <code>/tasks/new</code>, Flask yrittää näyttää käyttäjälle tiedostoa <code>new.html</code> kansiosta <code>tasks</code>.
</p>

<p>
  Luodaan kyseinen tiedosto seuraavaksi. Luodaan kansioon <code>templates</code> kansio <code>tasks</code>, johon tulee tehtävien hallintaan liittyvät HTML-sivut. Luodaan tämän jälkeen kansioon <code>tasks</code> tiedosto <code>new.html</code>, jota käytetään uuden tehtävän lisäämiseen.
</p>

<% partial 'partials/xml_highlight' do %>
  {% extends "layout.html" %}
  
  {% block body %}
  &lt;form method="POST" action="{{ url_for('tasks_create') }}"&gt;
    &lt;input type="text" name="name"/&gt;
    &lt;input type="submit" value="Add a new task"/&gt;
  &lt;/form&gt;
  {% endblock %}
<% end %>

<p>
  Sivu on muuten tutun näköinen, mutta lomakkeen action-attribuutille annettu arvo <code>{{ url_for('tasks_create') }}</code> on ensi näkymältä hieman hämmentävä. Kyseessä on Flaskin tarjoama funktio, joka selvittää <code>tasks_create</code>-nimisen funktion kuunteleman osoitteen. Käytännössä <code>url_for</code> etsii sille annettua nimeä kaikista <code>@app.route</code>-dekoraattorilla (tai Javan termein annotaatiolla) merkityistä funktioista. Funktio löytyy <code>tasks</code>-kansion <code>views.py</code>-tiedostosta, missä se on kytketty <code>/tasks</code>-polkuun. Lopulta action-kentän arvoksi tulee siis <code>/tasks</code>.
</p>

<p>
  Kokeillaan sovelluksen toimintaa -- mennään osoitteeseen <a href="http://localhost:5000/tasks/new/" target="_blank" norel>http://localhost:5000/tasks/new/</a>, missä pitäisi olla lomake, jolla voidaan lähettää tietoa palvelimelle.
</p>

<img src="/img/tasks-new-not-found.png" alt="Not found." />

<p>
  Déjà vu -- tuntuu tutulta.
</p>

<p>
  Sivu näyttää viestin "Not Found". Tämä johtuu siitä, että kansion <code>application</code> sisällä olevassa kansiossa <code>tasks</code> olevaa <code>views.py</code> tiedostoa ei ole ladattu sovelluksen käyttöön. Muokataan kansion <code>application</code> tiedostoa <code>__init__.py</code> ja ladataan kyseinen tiedosto käyttöön.
</p>

<p>
  Tiedosto <code>__init__.py</code> on nyt kokonaisuudessaan seuraavanlainen.
</p>

<% partial 'partials/python_highlight' do %>
  from flask import Flask
  app = Flask(__name__)

  from flask_sqlalchemy import SQLAlchemy
  app.config["SQLALCHEMY_DATABASE_URI"] = "sqlite:///tasks.db"
  app.config["SQLALCHEMY_ECHO"] = True

  db = SQLAlchemy(app)

  from application import views

  from application.tasks import models
  from application.tasks import views
  
  db.create_all()
<% end %>

<p>
  Tarkastellaan sivua uudestaan.
</p>


<img src="/img/tasks-new-found.png" alt="Sivu löytyy ja siellä näkyy lomake." />

<p>
  Sivu löytyy ja sivulla näkyy lomake. Kirjoitetaan lomakkeeseen teksti "Hei maailma" ja painetaan nappia "Add a new task". Päädymme osoitteeseen "/tasks/" ja näemme sivun, jossa lukee "hello world!". 
</p>

<img src="/img/tasks-hello-world.png" alt="Sivulla näkyy teksti 'hello world!'." />

<p>
  Tarkastellaan vielä sovelluksen logeja. Logeissa pitäisi näkyä aiemmin lähettämämme teksti.
</p>


<% partial 'partials/terminal' do %>
  (venv) ~/todosovellus$ sqlite3 application/tasks.db
  ...
  * Debugger is active!
  * Debugger PIN: 140-705-069
  Hei maailma!
  127.0.0.1 - - [29/Feb/2018 22:44:08] "POST /tasks/ HTTP/1.1" 200 -
<% end %>

<p>
  Näyttää toimivan oikein. Saamme lähetettyä palvelimelle viestin lomakkeesta, ja saamme palvelimella luettua lomakkeelta lähetetyn kentän arvon.
</p>

<p>
  Lisätään palvelimelle seuraavaksi toiminnallisuus, millä lomakkeella lähetetty tieto tallennetaan tietokantaan. Muokataan kansiossa <code>tasks</code> olevaa tiedostoa <code>views.py</code> siten, että funtio <code>tasks_create</code> lisää rivin tietokantaan. 
</p>

<p>
  Lisätään tiedostoon tarvittavat "importit" eli tietokannan käyttöön liittyvä toiminnallisuus. Muuttuja <code>db</code> liittyy Flaskin SQLAlchemy-liitännäiseen, ja se tarjoaa tietokantaan lisäämiseen tarvittavaa toiminnallisuutta. Kutsulla <code>db.session().add(olio)</code> harkitsemme uuden olion lisäämistä tietokantaan ja kutsulla <code>db.session().commit()</code> teemme harkinnasta totta. Lisää SQLAlchemyn sessioista osoitteessa <a href="https://docs.sqlalchemy.org/en/latest/orm/session.html" target="_blank" norel>http://docs.sqlalchemy.org/en/latest/orm/session.html</a>.
</p>

<% partial 'partials/python_highlight' do %>
  from application import app, db
  from flask import render_template, request
  from application.tasks.models import Task

  @app.route("/tasks/new/")
  def tasks_form():
      return render_template("tasks/new.html")

  @app.route("/tasks/", methods=["POST"])
  def tasks_create():
      t = Task(request.form.get("name"))

      db.session().add(t)
      db.session().commit()
  
      return "hello world!"
<% end %>

<p>
  Käytetään lomaketta samalla tavalla kuin edellä -- eli lähetetään lomakkeella teksti "hei maailma!" -- ja tarkastellaan tiedokannan sisältöä SQLiten avulla.
</p>


<% partial 'partials/terminal' do %>
  (venv) ~/todosovellus$ sqlite3 application/tasks.db
  SQLite version 3.11.0 2016-02-15 17:29:24
  Enter ".help" for usage hints.
  sqlite&gt; SELECT * FROM Task;
  1|2018-02-29 20:53:11|2018-02-29 20:53:11|Hei maailma!|0
  sqlite&gt; .exit
  (venv) ~/todosovellus$
<% end %>

<p>
  Tietokantaan menee tietoa, huraa!
</p>


<% partial 'partials/material_sub_heading' do %>
  Lisäämisen järkevöittäminen ja tiedon listaaminen
<% end %>

<p>
  Lisätään seuraavaksi toiminnallisuus tehtävien listaamiseen ja järkevöitetään lisäystoiminnallisuutta. Luodaan ensin listaukseen käytettävä sivu <code>list.html</code>, joka asetetaan <code>templates</code>-kansion alla olevaan <code>tasks</code>-kansioon. Listataan jokaisesta tehtävästä nimi sekä tieto siitä, onko tehtävä tehty. 
</p>

<p>
  HTML-sivu on seuraava.
</p>


<% partial 'partials/xml_highlight' do %>
{% extends "layout.html" %}

{% block body %}
  &lt;table&gt;
    &lt;tr&gt;
      &lt;th&gt;Task&lt;/th&gt;
      &lt;th&gt;Done&lt;/th&gt;
    &lt;/tr&gt;
    {% for task in tasks %}
    &lt;tr&gt;
      &lt;td&gt;{{ task.name }}&lt;/td&gt;
      &lt;td&gt;{{ task.done }}&lt;/td&gt;
    &lt;/tr&gt;
    {% endfor %}
  &lt;/table&gt;
{% endblock %}
<% end %>

<p>
  Sivulla odotetaan <code>tasks</code>-nimistä listaa. Luodaan seuraavaksi tehtävien näyttämiseen tarkoitettuun <code>views.py</code>-tiedostoon toiminnallisuus tehtävien listaamiseen liittyen. Luodaan funktio <code>tasks_index</code>, joka kuuntelee GET-tyyppisiä pyyntöjä polkuun <code>/tasks</code>. Funktio renderöi kansiosta <code>tasks</code> sivun <code>list.html</code>. Sivun luomista varten annetaan lista kaikista tehtävistä. Kaikkien tehtävien hakeminen (eli "SELECT * FROM Task") onnistuu SQLAlchemyn kutsulla <code>Task.query.all()</code>.
</p>

<% partial 'partials/python_highlight' do %>
  from application import app, db
  from flask import render_template, request
  from application.tasks.models import Task

  @app.route("/tasks", methods=["GET"])
  def tasks_index():
      return render_template("tasks/list.html", tasks = Task.query.all())

  @app.route("/tasks/new/")
  def tasks_form():
      return render_template("tasks/new.html")

  @app.route("/tasks/", methods=["POST"])
  def tasks_create():
      t = Task(request.form.get("name"))

      db.session().add(t)
      db.session().commit()
  
      return "hello world!"
<% end %>

<p>
  Nyt osoitteessa <code>/tasks</code> listataan tietokannassa olevat tehtävät, ja osoitteessa <code>/tasks/new</code> voi luoda uuden tehtävän tietokantaan.
</p>

<p>
  Muokataan sovellusta vielä siten, että tehtävän lisäämisen jälkeen käyttäjä ohjataan sivulle, missä tehtävät listataan. Tämä tapahtuu Pythonin <code>redirect</code>-funktion avulla. Funktiolle annetaan polku, johon pyyntö uudelleenohjataan -- tässä uudelleenohjaus tehdään polkuun, johon liittyvän funktion nimi on <code>tasks_index</code> -- polun määrittely tapahtuu funktiolle <code>url_for</code>. Myös nämä funktiot tulee tuoda Flaskin käyttöön.  
</p>

<% partial 'partials/python_highlight' do %>
  from application import app, db
  from flask import redirect, render_template, request, url_for
  from application.tasks.models import Task

  @app.route("/tasks", methods=["GET"])
  def tasks_index():
      return render_template("tasks/list.html", tasks = Task.query.all())

  @app.route("/tasks/new/")
  def tasks_form():
      return render_template("tasks/new.html")

  @app.route("/tasks/", methods=["POST"])
  def tasks_create():
      t = Task(request.form.get("name"))

      db.session().add(t)
      db.session().commit()
  
      return redirect(url_for("tasks_index"))
<% end %>

<p>
  Nyt tehtävien luominen sekä listaus toimii.
</p>
  
<img src="/img/tehtavien-luominen.gif" alt="Animaatio, joka näyttää tehtävien luomisen." />


<% partial 'partials/material_sub_heading' do %>
  Tehtävän tehdyksi merkkaaminen
<% end %>

<p>
  Lisätään sovellukseen seuraavaksi toiminnallisuus tehtävän tehdyksi merkkaamiseen. Sovitaan, että pyyntö osoitteeseen <code>/tasks/42</code> muuntaa tehtävän, jonka pääavain on 42, tehdyksi.
</p>

<p>
  Polkuihin asetettavat parametrit saadaan kiinni Flaskissa pienempi- ja suurempi kuin-merkkien avulla. Alla kuvattu funktio <code>tasks_set_done</code> käsittelee POST-tyyppisiä pyyntöjä osoitteeseen <code>/tasks/(jotain)</code>. Pyynnöstä saatu parametri asetetaan suoraan funktion parametriksi.
</p>

<p>
  Tietokantatoiminnallisuus toimii siten, että haemme annettua pääavainta vastaavan tietokantarivin. Esimerkiksi kutsu <code>Task.query.get(42)</code> palauttaisi tehtävän, jonka pääavaimen arvo on <code>42</code>. Alla pääavaimen arvo otetaan suoraan polusta. Funktio muuttaa tehtävän tehdyksi, jonka jälkeen muutos viedään tietokantaan.
</p>


<% partial 'partials/python_highlight' do %>
  from application import app, db
  from flask import redirect, render_template, request, url_for
  from application.tasks.models import Task

  @app.route("/tasks", methods=["GET"])
  def tasks_index():
      return render_template("tasks/list.html", tasks = Task.query.all())

  @app.route("/tasks/new/")
  def tasks_form():
      return render_template("tasks/new.html")
  
  @app.route("/tasks/&lt;task_id&gt;/", methods=["POST"])
  def tasks_set_done(task_id):

      t = Task.query.get(task_id)
      t.done = True
      db.session().commit()
  
      return redirect(url_for("tasks_index"))

  @app.route("/tasks/", methods=["POST"])
  def tasks_create():
      t = Task(request.form.get("name"))

      db.session().add(t)
      db.session().commit()
  
      return redirect(url_for("tasks_index"))
<% end %>

<p>
  Funktion <code>tasks_set_done</code> sisällä tapahtuva tietokannasta haetun tehtävän muuntaminen on mielenkiintoista. Missään ei oikeastaan sanota, että juuri kyseinen tehtävä pitäisi tallentaa tietokantaan. Flask ja SQLAlchemy toimivat yhdessä kuten hyvin monet muut Web-sovelluskehykset ja ORM-kirjastot -- tietokannasta haettava olio on hallinnoitu, ja siihen tapahtuvia muutoksia tarkastellaan sovelluksen toimesta. Kun funktiossa <code>tasks_set_done</code> tehdään kutsu <code>db.session().commit()</code>, SQLAlchemy tietää että tehtävä on muuttunut ja tallentaa sen tietokantaan.
</p>

<p>
  Lisätään vielä tehtävien listaussivulle <code>list.html</code> mahdollisuus tehtävän muuttamiseen tehdyksi. Huomaa alla, miten lomake lähetetään funktioon <code>tasks_set_done</code> liittyvään osoitteeseen ja miten lomakkeelle määritellään funktion tarvitsema parametri <code>task_id</code>. 
</p>
  

<% partial 'partials/xml_highlight' do %>
{% extends "layout.html" %}

{% block body %}
  &lt;table&gt;
    &lt;tr&gt;
      &lt;th&gt;Task&lt;/th&gt;
      &lt;th&gt;Done&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
    &lt;/tr&gt;
    {% for task in tasks %}
    &lt;tr&gt;
      &lt;td&gt;{{ task.name }}&lt;/td&gt;
      &lt;td&gt;{{ task.done }}&lt;/td&gt;
      &lt;td&gt;
	&lt;form method="POST" action="{{ url_for('tasks_set_done', task_id=task.id) }}"&gt;
	  &lt;input type="submit" value="Change status!"/&gt;
	&lt;/form&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
    {% endfor %}
  &lt;/table&gt;
{% endblock %}
<% end %>

<p>
  Nyt myös tehtävien muuntaminen tehdyiksi onnistuu.
</p>

<img src="/img/tehtavien-merkinta-tehdyksi.gif" alt="Animaatio, joka näyttää tehtävän merkinnän tehdyksi." />


<% partial 'partials/material_sub_heading' do %>
  Pieni käytettävyysparannus
<% end %>

<p>
  Sovellus on tällä hetkellä hieman hölmö, sillä jokainen osoite tulee muistaa ulkoa. Muokataan sovellusta siten, että asettelusivulla <code>layout.html</code> on linkit oleellisiin sivuihin.
</p>

<% partial 'partials/xml_highlight' do %>
  &lt;!DOCTYPE html&gt;
  &lt;html&gt;
    &lt;head&gt;
      &lt;meta charset="utf-8"&gt;
      &lt;title&gt;TodoApplication&lt;/title&gt;
    &lt;/head&gt;
    
    &lt;body&gt;
      &lt;ul&gt;
	&lt;li&gt;&lt;a href="{{ url_for('tasks_index') }}"&gt;List tasks&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;&lt;a href="{{ url_for('tasks_form') }}"&gt;Add a task&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
      
      {% block body %}
      &lt;p&gt;
	Content.
      &lt;/p&gt;
      {% endblock %}
    &lt;/body&gt;
  &lt;/html&gt;
<% end %>

<p>
  Nyt sivuilla on pysyvä valikko, jonka avulla oleelliset toiminnallisuudet löytyvät helposti.
</p>


<img src="/img/tehtavasivu.gif" alt="Animaatio, joka näyttää sivuilla navigoinnin." />


<% partial 'partials/material_sub_heading' do %>
  Riippuvuuksien päivitys
<% end %>

<p>
  Päivitetään vielä lopulta tiedostossa <code>requirements.txt</code> olevat riippuvuudet.
</p>

<% partial 'partials/terminal' do %>
  (venv) ~/todosovellus$ pip freeze | grep -v pkg-resources > requirements.txt
  (venv) ~/todosovellus$ cat requirements.txt
  click==6.7
  Flask==0.12.2
  Flask-SQLAlchemy==2.3.2
  gunicorn==19.7.1
  itsdangerous==0.24
  Jinja2==2.10
  MarkupSafe==1.0
  SQLAlchemy==1.2.5
  Werkzeug==0.14.1
  (venv) ~/todosovellus$ 
<% end %>

<p>
  Nyt sovelluksen voi taas siirtää Githubiin ja Herokuun. Muistathan varmistaa, että versionhallintaan ei päädy turhia tiedostoja, ja että sinne mahdollisesti päätyneet turhat tiedostot poistetaan.
</p>

<p>
  Sovellus löytyy tarkasteltavaksi osoitteessa <a href="https://github.com/avihavai/tsoha-18-vk2" target="_blank" norel>https://github.com/avihavai/tsoha-18-vk2</a>. Sovellus löytyy myös Herokusta osoitteessa <a href="https://tsoha-18-todo-vk2.herokuapp.com/" target="_blank" norel>https://tsoha-18-todo-vk2.herokuapp.com/</a>.
</p>


<% partial 'partials/hint', locals: { name: 'Riippuvuuksien lataaminen requirements.txt -tiedostosta' } do %>

  <p>
    Kun suoritamme komennon <code>pip freeze</code>, sovellus tulostaa projektiin liittyvät riippuvuudet. Seuraava sovellusta kehittävä henkilö saa riippuvuudet helposti käyttöönsä -- mikäli riippuvuudet on määritelty tiedostossa <code>requirements.txt</code>, onnistuu niiden lataaminen komennolla <code>pip install -r requirements.txt</code>.
  </p>
  

<% end %>
